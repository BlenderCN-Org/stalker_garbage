from struct import *def parse_header(s):    p = 0    format_version, type, shader_id = unpack('bbh', s[p : p + 4])    p += 4    print('  ver: {1}{0}type:{2}{0}shader: {3}'.format('\n  ', format_version, type, shader_id))    p += 24    p += 16def parse_geometry_container(s):    p = 0    vertex_buffer_set, vertex_base, vertex_count, \    index_buffer_set, index_base, index_count = \    unpack('6I', s[p : p + 24])        print('  vertex_buffer_set: {}'.format(vertex_buffer_set))    print('  vertex_base: {}'.format(vertex_base))    print('  vertex_count: {}'.format(vertex_count))    print('  index_buffer_set: {}'.format(index_buffer_set))    print('  index_base: {}'.format(index_base))    print('  index_count: {}'.format(index_count))    return vertex_buffer_set, vertex_base, vertex_count, index_buffer_set, index_base, index_countdef parse_visual(s):    p = 0    while p < len(s):        block_id, block_size = unpack('II', s[p : p + 8])        p += 8        if block_id == 0x0001:            parse_header(s[p : p + block_size])        elif block_id == 0x0015:            visual = parse_geometry_container(s[p : p + block_size])            return visual        else:            print(' ', hex(block_id))        p += block_sizedef parse(s):    p = 0    visuals = []    while p < len(s):        visual_id = unpack('i', s[p : p + 4])[0]        p += 4        print('Visual_%d'%visual_id)                visual_size = unpack('i', s[p : p + 4])[0]        p += 4                visuals.append(parse_visual(s[p : p + visual_size]))                p += visual_size    return visuals